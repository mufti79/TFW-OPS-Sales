
import React, { useState, useMemo } from 'react';
import { Ride } from '../types';

interface ReportsProps {
  dailyCounts: Record<string, Record<string, number>>;
  dailyRideDetails: Record<string, Record<string, { tickets: number; packages: number }>>;
  rides: Ride[];
}

// Helper function to get YYYY-MM-DD from a Date object based on local timezone
// Using explicit padStart ensures format matches standard HTML date inputs
const toLocalDateString = (date: Date): string => {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

const Reports: React.FC<ReportsProps> = ({ dailyCounts, dailyRideDetails, rides }) => {
  const [currentDate, setCurrentDate] = useState(new Date());
  const [selectedRange, setSelectedRange] = useState<{ start: Date | null; end: Date | null }>({ start: null, end: null });

  // Calculate aggregated data for the currently viewed month
  const monthData = useMemo(() => {
    const data = new Map<string, number>();
    // Ensure we are working with valid numbers
    const targetYear = currentDate.getFullYear();
    const targetMonthIndex = currentDate.getMonth(); // 0-11

    if (!dailyCounts) return data;

    Object.keys(dailyCounts).forEach(dateKey => {
        // Robustly parse the date key YYYY-MM-DD
        const parts = dateKey.split('-');
        if (parts.length === 3) {
            const y = parseInt(parts[0], 10);
            // dateKey month is 1-12, Date object needs 0-11
            const mIndex = parseInt(parts[1], 10) - 1; 
            const d = parseInt(parts[2], 10);

            // Check if this record belongs to the current view (Year and Month match)
            if (y === targetYear && mIndex === targetMonthIndex) {
                const dayCounts = dailyCounts[dateKey];
                let dailyTotal = 0;
                
                if (dayCounts && typeof dayCounts === 'object') {
                    Object.values(dayCounts).forEach(val => {
                        dailyTotal += (Number(val) || 0);
                    });
                }

                if (dailyTotal > 0) {
                    // Create a Date object and convert it back to string using the SAME function as the UI
                    // This guarantees that the key in the Map matches the key generated by the calendar grid
                    const dateObj = new Date(y, mIndex, d);
                    const normalizedKey = toLocalDateString(dateObj);
                    
                    data.set(normalizedKey, (data.get(normalizedKey) || 0) + dailyTotal);
                }
            }
        }
    });
    return data;
  }, [dailyCounts, currentDate]);
  
  const monthTotal = useMemo(() => {
    let total = 0;
    for (const count of monthData.values()) {
        total += count;
    }
    return total;
  }, [monthData]);

  const rangeTotal = useMemo(() => {
    if (!selectedRange.start || !selectedRange.end) return 0;
    
    let total = 0;
    let current = new Date(selectedRange.start);
    
    // Safety break to prevent infinite loops if dates are invalid
    let safegaurd = 0;
    while (current <= selectedRange.end && safegaurd < 366) {
        const dateStr = toLocalDateString(current);
        total += monthData.get(dateStr) || 0;
        current.setDate(current.getDate() + 1);
        safegaurd++;
    }
    return total;
  }, [selectedRange, monthData]);


  const handleDateClick = (day: Date) => {
    const { start, end } = selectedRange;
    
    // If a full range is already selected, or no start is selected, start a new selection.
    if (!start || (start && end)) {
        setSelectedRange({ start: day, end: null });
    } 
    // If a start date is selected but an end date is not, complete the range.
    else if (start && !end) {
        // If the newly selected day is before the start date, swap them to create a valid range.
        if (day < start) {
            setSelectedRange({ start: day, end: start });
        } else {
            setSelectedRange({ start: start, end: day });
        }
    }
  };
  
  const handleMonthChange = (offset: number) => {
    setCurrentDate(prev => {
        // Set date to the 1st of the target month to avoid overflow issues (e.g. Jan 31 -> Feb 28)
        return new Date(prev.getFullYear(), prev.getMonth() + offset, 1);
    });
    setSelectedRange({ start: null, end: null }); // Clear range on month change
  };
  
  const generateCalendarDays = () => {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const days = [];
    
    // Add blank days for the start of the month
    for (let i = 0; i < firstDay.getDay(); i++) {
      days.push(null);
    }
    
    // Add all days of the month
    for (let i = 1; i <= lastDay.getDate(); i++) {
      days.push(new Date(year, month, i));
    }
    
    return days;
  };

  const calendarDays = generateCalendarDays();
  const weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

  // Calculate Breakdown Data for the table below calendar
  const breakdownData = useMemo(() => {
    const rideStats: Record<string, { total: number; tickets: number; packages: number }> = {};
    const rideMap = new Map<string, Ride>(rides.map(r => [r.id.toString(), r]));

    const targetYear = currentDate.getFullYear();
    const targetMonthIndex = currentDate.getMonth();

    Object.keys(dailyCounts).forEach(dateKey => {
         const parts = dateKey.split('-');
         if (parts.length === 3) {
             const y = parseInt(parts[0], 10);
             const mIndex = parseInt(parts[1], 10) - 1;
             const d = parseInt(parts[2], 10);
             
             let include = false;
             
             // Check Date Range or Month Match
             if (selectedRange.start && selectedRange.end) {
                 const dateObj = new Date(y, mIndex, d);
                 // Reset hours to ensure clean comparison
                 dateObj.setHours(0,0,0,0);
                 const start = new Date(selectedRange.start); start.setHours(0,0,0,0);
                 const end = new Date(selectedRange.end); end.setHours(0,0,0,0);
                 
                 if (dateObj >= start && dateObj <= end) {
                     include = true;
                 }
             } else {
                 // Month Check
                 if (y === targetYear && mIndex === targetMonthIndex) {
                     include = true;
                 }
             }

             if (include) {
                const dayCounts = dailyCounts[dateKey];
                const dayDetails = dailyRideDetails[dateKey] || {};

                if (dayCounts && typeof dayCounts === 'object') {
                    Object.entries(dayCounts).forEach(([rideId, count]) => {
                        const val = Number(count) || 0;
                        if (val > 0) {
                            if (!rideStats[rideId]) {
                                rideStats[rideId] = { total: 0, tickets: 0, packages: 0 };
                            }
                            
                            rideStats[rideId].total += val;
                            
                            const details = dayDetails[rideId];
                            if (details) {
                                rideStats[rideId].tickets += (Number(details.tickets) || 0);
                                rideStats[rideId].packages += (Number(details.packages) || 0);
                            } else {
                                // Default to tickets if breakdown is missing (legacy support)
                                rideStats[rideId].tickets += val;
                            }
                        }
                    });
                }
             }
         }
    });

    return Object.entries(rideStats)
        .map(([rideId, stats]) => {
            const ride = rideMap.get(rideId);
            return {
                name: ride?.name || `Unknown Ride (${rideId})`,
                floor: ride?.floor || 'N/A',
                ...stats
            };
        })
        .sort((a, b) => b.total - a.total);
  }, [dailyCounts, dailyRideDetails, currentDate, selectedRange, rides]);


  const handleDownloadMonthReport = () => {
    const monthRideStats: Record<string, { total: number; tickets: number; packages: number }> = {};
    const targetYear = currentDate.getFullYear();
    const targetMonthIndex = currentDate.getMonth();

    Object.keys(dailyCounts).forEach(dateKey => {
        const parts = dateKey.split('-');
        if (parts.length === 3) {
            const y = parseInt(parts[0], 10);
            const mIndex = parseInt(parts[1], 10) - 1;
            
            if (y === targetYear && mIndex === targetMonthIndex) {
                 const dayCounts = dailyCounts[dateKey];
                 const dayDetails = dailyRideDetails[dateKey] || {};

                 if (dayCounts && typeof dayCounts === 'object') {
                     Object.entries(dayCounts).forEach(([rideId, count]) => {
                        const val = Number(count) || 0;
                        if (val > 0) {
                            if (!monthRideStats[rideId]) monthRideStats[rideId] = { total: 0, tickets: 0, packages: 0 };
                            
                            monthRideStats[rideId].total += val;
                            const details = dayDetails[rideId];
                            if (details) {
                                monthRideStats[rideId].tickets += (Number(details.tickets) || 0);
                                monthRideStats[rideId].packages += (Number(details.packages) || 0);
                            } else {
                                monthRideStats[rideId].tickets += val;
                            }
                        }
                     });
                 }
            }
        }
    });
    
    const rideIdMap = new Map<string, Ride>(rides.map(r => [r.id.toString(), r]));
    const reportData = Object.entries(monthRideStats).map(([rideId, stats]) => {
        const ride = rideIdMap.get(rideId);
        return {
            name: ride?.name || 'Unknown Ride',
            floor: ride?.floor || 'N/A',
            ...stats
        };
    }).sort((a,b) => b.total - a.total);

    if (reportData.length === 0) {
        alert("No data available to download for this month.");
        return;
    }

    const headers = ['Ride Name', 'Floor', 'Tickets', 'Packages', 'Total Guests'];
    const rows = reportData.map(item => `"${item.name}","${item.floor}",${item.tickets},${item.packages},${item.total}`);
    const csvContent = [headers.join(','), ...rows].join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `TFW_Monthly_Breakdown_${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}.csv`;
    link.click();
  };

  const handleDownloadRangeReport = () => {
    if (!selectedRange.start || !selectedRange.end) return;
    
    const reportData = [];
    let current = new Date(selectedRange.start);
    // Safety limiter
    let i = 0;
    while (current <= selectedRange.end && i < 366) {
        const dateStr = toLocalDateString(current);
        const count = monthData.get(dateStr) || 0;
        reportData.push({
            date: dateStr,
            total: count
        });
        current.setDate(current.getDate() + 1);
        i++;
    }

    const headers = ['Date', 'Total Guests'];
    const rows = reportData.map(item => `${item.date},${item.total}`);
    const csvContent = [headers.join(','), ...rows].join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `TFW_Daily_Totals_${toLocalDateString(selectedRange.start)}_to_${toLocalDateString(selectedRange.end)}.csv`;
    link.click();
  };
  
  // New function to download the breakdown for the selected range/month
  const handleDownloadBreakdownCSV = () => {
      if (breakdownData.length === 0) {
          alert("No data to download.");
          return;
      }
      
      const headers = ['Ride Name', 'Floor', 'Tickets', 'Packages', 'Total Guests'];
      const rows = breakdownData.map(item => `"${item.name}","${item.floor}",${item.tickets},${item.packages},${item.total}`);
      const csvContent = [headers.join(','), ...rows].join('\n');
      
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      const filename = selectedRange.start && selectedRange.end 
        ? `TFW_Breakdown_${toLocalDateString(selectedRange.start)}_to_${toLocalDateString(selectedRange.end)}.csv`
        : `TFW_Breakdown_${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}.csv`;
      link.download = filename;
      link.click();
  };


  // Handler for month/year picker change
  const handleMonthYearPickerChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value; // Format: YYYY-MM
    if (value) {
      const [year, month] = value.split('-').map(Number);
      setCurrentDate(new Date(year, month - 1, 1));
      setSelectedRange({ start: null, end: null }); // Clear range on manual date change
    }
  };

  // Format current date for the month picker input (YYYY-MM format)
  const currentMonthValue = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;

  return (
    <div className="flex flex-col animate-fade-in-down">
       <div className="flex flex-col sm:flex-row justify-between items-center gap-4 mb-8 p-4 bg-gray-800/50 rounded-lg border border-gray-700">
            <h1 className="text-2xl md:text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">
                Operational Report
            </h1>
            <div className="flex flex-col sm:flex-row items-center gap-4">
                {/* Month/Year Picker */}
                <input 
                    type="month" 
                    value={currentMonthValue}
                    onChange={handleMonthYearPickerChange}
                    className="px-4 py-2 bg-gray-700 text-gray-200 rounded-lg border border-gray-600 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500 transition-colors cursor-pointer"
                    title="Select month and year"
                />
                {/* Navigation Buttons */}
                <div className="flex items-center gap-2">
                    <button onClick={() => handleMonthChange(-1)} className="p-2 rounded-full bg-gray-700 hover:bg-gray-600 transition-colors" title="Previous month">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" /></svg>
                    </button>
                    <span className="text-xl font-semibold w-48 text-center text-gray-200">
                        {currentDate.toLocaleString('default', { month: 'long', year: 'numeric' })}
                    </span>
                    <button onClick={() => handleMonthChange(1)} className="p-2 rounded-full bg-gray-700 hover:bg-gray-600 transition-colors" title="Next month">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" /></svg>
                    </button>
                </div>
            </div>
            <button onClick={() => setSelectedRange({start: null, end: null})} className="text-sm text-gray-400 hover:text-white">Clear Selection</button>
        </div>

        <div className="bg-gray-800 rounded-lg shadow-lg overflow-hidden border border-gray-700">
            <div className="grid grid-cols-7 text-center font-semibold text-gray-400 border-b border-gray-700">
                {weekDays.map(day => <div key={day} className="py-3">{day}</div>)}
            </div>
            <div className="grid grid-cols-7">
                {calendarDays.map((day, index) => {
                    if (!day) return <div key={`empty-${index}`} className="border-r border-b border-gray-700 h-32 bg-gray-800/30"></div>;
                    
                    const dateStr = toLocalDateString(day);
                    const count = monthData.get(dateStr) || 0;
                    
                    const isPending = selectedRange.start && !selectedRange.end && selectedRange.start.getTime() === day.getTime();
                    const inRange = selectedRange.start && selectedRange.end && day >= selectedRange.start && day <= selectedRange.end;
                    const isStart = selectedRange.start?.getTime() === day.getTime();
                    const isEnd = selectedRange.end?.getTime() === day.getTime();

                    const cellClasses = [
                        "p-2 h-32 flex flex-col justify-between border-r border-b border-gray-700 cursor-pointer transition-all",
                        inRange ? "bg-purple-900/40" : "hover:bg-gray-700/50",
                        isPending && "bg-purple-700/50 ring-2 ring-purple-400 z-10",
                        (isStart || isEnd) && "bg-purple-600 text-white shadow-lg z-10",
                    ].filter(Boolean).join(' ');

                    return (
                        <div key={dateStr} className={cellClasses} onClick={() => handleDateClick(day)}>
                            <span className={`font-bold ${isStart || isEnd ? 'text-white' : 'text-gray-400'}`}>{day.getDate()}</span>
                            {count > 0 && (
                                <span className={`text-lg font-bold self-end tabular-nums ${(isStart || isEnd) ? 'text-white' : 'text-pink-400'}`}>
                                    {count.toLocaleString()}
                                </span>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-8">
            <div className="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                <h3 className="text-lg font-semibold text-gray-300">Selected Range Total</h3>
                <p className="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">
                    {rangeTotal.toLocaleString()}
                </p>
                <p className="text-sm text-gray-500 mt-1">
                    {selectedRange.start && selectedRange.end ? `${selectedRange.start.toLocaleDateString()} - ${selectedRange.end.toLocaleDateString()}` : "Select dates to see range total"}
                </p>
            </div>
             <div className="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                <h3 className="text-lg font-semibold text-gray-300">Month Total</h3>
                <p className="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-teal-400 to-cyan-500">
                    {monthTotal.toLocaleString()}
                </p>
                <p className="text-sm text-gray-500 mt-1">
                    Total guests for {currentDate.toLocaleString('default', { month: 'long', year: 'numeric' })}
                </p>
            </div>
        </div>

        {/* Breakdown Table */}
        <div className="mt-8 bg-gray-800 rounded-lg shadow-lg overflow-hidden border border-gray-700">
            <div className="p-4 border-b border-gray-700 bg-gray-800/50 flex flex-col sm:flex-row justify-between items-center gap-4">
                <h3 className="text-xl font-bold text-gray-200">
                    Ride Breakdown 
                    <span className="text-sm font-normal text-gray-400 ml-2">
                        ({selectedRange.start && selectedRange.end ? 'Selected Range' : 'Current Month'})
                    </span>
                </h3>
                <button 
                    onClick={handleDownloadBreakdownCSV}
                    disabled={breakdownData.length === 0}
                    className="px-4 py-2 bg-green-700 text-white font-semibold rounded-lg text-sm hover:bg-green-600 disabled:bg-gray-700 disabled:text-gray-500 disabled:cursor-not-allowed transition-colors"
                >
                    Download Breakdown CSV
                </button>
            </div>
            {breakdownData.length > 0 ? (
                <div className="overflow-x-auto">
                    <table className="w-full text-left min-w-[600px]">
                        <thead className="bg-gray-700/50">
                            <tr>
                                <th className="p-4 font-semibold w-16 text-center text-gray-300">Rank</th>
                                <th className="p-4 font-semibold text-gray-300">Ride Name</th>
                                <th className="p-4 font-semibold text-gray-300">Floor</th>
                                <th className="p-4 font-semibold text-right text-purple-300">Tickets</th>
                                <th className="p-4 font-semibold text-right text-pink-300">Packages</th>
                                <th className="p-4 font-semibold text-right text-white">Total Guests</th>
                            </tr>
                        </thead>
                        <tbody>
                            {breakdownData.map((item, index) => (
                                <tr key={index} className="border-t border-gray-700 hover:bg-gray-700/30 transition-colors">
                                    <td className="p-4 text-center text-gray-500 font-bold">{index + 1}</td>
                                    <td className="p-4 font-medium text-gray-200">{item.name}</td>
                                    <td className="p-4 text-gray-400 text-sm">{item.floor}</td>
                                    <td className="p-4 text-right tabular-nums text-purple-400">{item.tickets.toLocaleString()}</td>
                                    <td className="p-4 text-right tabular-nums text-pink-400">{item.packages.toLocaleString()}</td>
                                    <td className="p-4 text-right font-bold text-white tabular-nums">{item.total.toLocaleString()}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            ) : (
                <div className="p-12 text-center">
                    <p className="text-gray-500 text-lg">No guest count data available for this period.</p>
                    <p className="text-gray-600 text-sm mt-2">Ensure operators have entered data in the G&R section.</p>
                </div>
            )}
        </div>
    </div>
  );
};

export default Reports;
